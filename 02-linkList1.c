//#include "02-linkList1.h"
//
////初始化链表
//struct LinkNode* initLinkList()
//{
//	//创建头节点
//	struct LinkNode* pHeader = malloc(sizeof(struct LinkNode));
//	if (pHeader == NULL)
//	{
//		return NULL;
//	}
//	//初始化头节点
//	//pHeader->num = -1;  //头节点 不维护数据域
//	pHeader->next = NULL;
//	//记录尾节点位置，方便插入新的数据
//	struct LinkNode* pTail = pHeader;
//	int val = -1;
//	while (1)
//	{
//		//让用户初始化几个节点，如果用户输入的是-1，代表插入结束
//		printf("请初始化链表，如果输入-1代表结束\n");
//		scanf("%d", &val);
//		if (val == -1)
//		{
//			break;
//		}
//		//如果输入不是-1  插入节点到链表中
//		struct LinkNode* newNode = malloc(sizeof(struct LinkNode));
//		newNode->num = val;
//		newNode->next = NULL;
//		//更改指针的指向
//		pTail->next = newNode;
//		//更新新的尾节点的指向
//		pTail = newNode;
//	}
//	return pHeader;
//}
//
////遍历链表
//void foreach_LinkList(struct LinkNode* pHeader)
//{
//	if (pHeader == NULL)
//	{
//		return;
//	}
//	struct LinkNode* pCurrent = pHeader->next; //指定第一个有真实数据的节点
//	while (pCurrent != NULL)
//	{
//		printf("%d\n", pCurrent->num);
//		pCurrent = pCurrent->next;
//	}
//}
//
////插入链表   new插在old前面 如果没有对应old，则插到末尾
//void insert_LinkList(struct LinkNode* pHeader, int oldVal, int newVal)
//{
//	if (pHeader == NULL)
//	{
//		return;
//	}
//	//创建两个临时的节点
//	struct LinkNode* pPrve = pHeader;
//	struct LinkNode* pCurrent = pHeader->next;
//	while (pCurrent != NULL)
//	{
//		if (pCurrent->num == oldVal)
//		{
//			break;
//		}
//		//如果没找到对应的位置,辅助指针向后移动
//		pPrve = pCurrent;
//		pCurrent = pCurrent->next;//这两行代码先后顺序不能变
//	}
//	//创建新节点
//	struct LinkNode* newNode = malloc(sizeof(struct LinkNode));
//	newNode->num = newVal;
//	newNode->next = NULL;
//	//建立关系
//	newNode->next = pCurrent;
//	pPrve->next = newNode;
//}
//
////删除链表
//void delete_LinkList(struct LinkNode* pHeader, int val)
//{
//	if (pHeader == NULL)
//	{
//		return;
//	}
//	//创建两个辅助指针变量
//	struct LinkNode* pPrev = pHeader;
//	struct LinkNode* pCurrent = pHeader->next;
//	while (pCurrent != NULL)
//	{
//		if (pCurrent->num == val)
//		{
//			break;
//		}
//		//没有找到数据，辅助指针向后移动
//		pPrev = pCurrent;
//		pCurrent = pCurrent->next;
//	}
//	if (pCurrent == NULL) //没有找到用户要删除的数据
//	{
//		return;
//	}
//	//更改指针的指向进行删除
//	pPrev->next = pCurrent->next;
//	//删除掉待删除的节点
//	free(pCurrent);
//	pCurrent = NULL;
//}
//
////清空链表
//void clear_LinkList(struct LinkNode* pHeader)
//{
//	if (pHeader == NULL)
//	{
//		return;
//	}
//	struct LinkNode* pCurrent = pHeader->next;
//	while (pCurrent != NULL)
//	{
//		//先保存住下一个节点的位置
//		struct LinkNode* nextNode = pCurrent->next;
//
//		free(pCurrent);
//
//		pCurrent = nextNode;
//	}
//	pHeader->next = NULL;
//}
//
////销毁链表
//void destroy_LinkList(struct LinkNode* pHeader)
//{
//	if (pHeader == NULL)
//	{
//		return;
//	}
//	//先清空链表
//	clear_LinkList(pHeader);
//	//再释放头节点
//	free(pHeader);
//	pHeader = NULL;
//}
//
////反转链表
//void reverse_LinkList(struct LinkNode* pHeader)
//{
//	if (pHeader == NULL)
//	{
//		return;
//	}
//	struct LinkNode* pPrev = NULL;
//	struct LinkNode* pCurrent = pHeader->next;
//	struct LinkNode* pNext = NULL;
//	while (pCurrent != NULL)
//	{
//		pNext = pCurrent->next;
//		pCurrent->next = pPrev;
//		pPrev = pCurrent;
//		pCurrent = pNext;
//	}
//	pHeader->next = pPrev;
//}
//
////返回链表节点个数
//int size_LinkList(struct LinkNode* pHeader)
//{
//	if (pHeader == NULL)
//	{
//		return -1;
//	}
//	struct LinkNode* pCurrent = pHeader->next;
//	int num = 0;
//	while (pCurrent != NULL)
//	{
//		num++;
//		pCurrent = pCurrent->next;
//	}
//	return num;
//}